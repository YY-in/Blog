---

title: 51单片机汇编指令
tag : [IC,单片机]
categories : [硬件]
description : 关于51单片机的结构、汇编指令、相关应用
date: 2022-5-2 23:41:00
---

<https://blog.csdn.net/acslsr/article/details/106881712>

# 1. 单片机基础知识

* 控制性能和可靠性高

    实时控制功能特别强，其CPU可以对I/O端口直接进行操作，位操作能力更是其它计算机无法比拟的。另外，由于CPU、存储器及I/O接口集成在同一芯片内，各部件间的连接紧凑，数据在传送时受干扰的影响较小，且不易受环境条件的影响，所以单片机的可靠性非常高。

* 体积小、价格低、易于产品化&#x20;

    单片机芯片即是一台完整的微型计算机，对于批量大的专用场合，一方面可以在众多的单片机品种间进行匹配选择；同时还可以专门进行芯片设计，使芯片的功能与应用具有良好的对应关系；在单片机产品的引脚封装方面，有的单片机引脚已减少到8个或更少。

    从而使应用系统的印制板减小、接插件减少，安装简单方便。

![](/image/image_OjxVvD8vEg.png)

![](/image/image_Y0pi37uX7X.png)

# 2.单片机结构与时序

## 2.1 80C51的基本结构和应用模式

![](/image/image_r6MItUgdLk.png)

在片内有储器的配置上，该系列单片机有四种形式

| 存储 | ROM   | EPROM | Flash | ROMLess |
| -- | ----- | ----- | ----- | ------- |
| 大小 | 4k    | 4k    | 4k    |         |
| 型号 | 80C51 | 87C51 | 89C51 | 80C51   |

* 无ROM（即ROMLess）型，应用时要在片外扩展程序存储器；

* 掩膜ROM（即MaskROM）型，用户程序由芯片生产厂写入；

* EPROM型，用户程序通过写入装置写入，通过紫外线照射擦除；

* FlashROM型，用户程序可以电写入或擦除（当前常用方式）。

还有OTPROM型（一次性编程写入ROM） 产品，具有较高的环境适应性和可靠性。

## 2.2 80C51典型产品资源配置

![](/image/6DCCB42B-098F-440B-97BD-9B7AECBE4EAC_pzlJ8tfOdZ.png)

**MCS-51单片机内部包含下列几个部件**：

* 一个8位CPU;

* 一个片内振荡器及时钟电路;

* 4KB ROM程序存储器；

* 128 B RAM数据存储器；

* 两个16位定时器/计数器；

* 可寻址64 KB外部数据存储器和64 KB外部程序存储器控制电路；

* 32条可编程的V/O线(四个8位并行1/0端口)；

* 一个可编程全双工串行口；

* 具有五个中断源、两个优先级嵌套中断结构。

## 2.3 80C51的引脚封装

![](/image/4F363333-7100-4A0A-95CB-BE866DDD6B64_8-q5r3EJCg.png)

* 40个引脚按功能分为3类：

  * 电源和时钟引脚：Vcc，GND，XTAL1(in)，XTAL2(out)

  * 编程控制引脚：RST,PSEN  ，ALE/PROG ，EA/Vpp

  * I/O端口引脚：P0，P1，P2，P3（必须掌握)

* RST（9脚）：RST即为RESET。

  * 当单片机振荡器工作时，该引脚上出现持续两个机器周期的高电平，就可实现复位操作，使单片机回复到初始状态。

  * 单片机复位后，从0000H地址处读取第一条指令并开始执行

* PSEN（29脚）：外部程序存储器的读选通信号,低电平有效。

  * 在对 外部程序存储器进行读操作 时，每个周期出现两次信号，连线时与外部ROM的OE引脚相连

  * 在读取外部的RAM时，该引脚不会有输出

  * 单片机内部已经有足够大的ROM，通常不需要外扩程序存储器，因此该引脚通常不使用

* ALE/PROG（30脚）：地址锁存信号输出端

  * 当外接存储器（ROM或RAM）时，ALE的输出用于锁存地址的低8位，一般ALE接锁存器的EN端

  * 当没有外部存储器时，ALE端可用于脉冲信号输出，且频率是石英振荡频率的1/6。

  * 在烧写EPROM时，该引脚用作编程脉冲PROG的输入端

* EA/Vpp（31脚）：访问程序存储器控制信号

  * 当该引脚接低电平时，对ROM的读操作限定于对外部程序存储器访问（内部的失效）

  * 当该引脚接高电平时，对ROM的读操作首先从内部ROM开始，内部访问完毕后才访问外部ROM

## 2.4  80C51的内部结构

### 2.4.1 基本结构

![](/image/image_hkx4EMhDrR.png)

**一、80C51的微处理器(CPU)**

* 运算器ALU

  * 加法器、暂存器、布尔处理器

* 控制器

  * 定时与控制逻辑、指令寄存器IR、振荡器

* 专用寄存器组

  * [程序计数器PC](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#uv5d1u4C4f745htS3hbd61 "程序计数器PC")、[累加器ACC](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#khg5xgcGjKh646F9MPmMfq "累加器ACC")、[寄存器B](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#fDdhLsxd6ZpByrHF19hFh "寄存器B")、[程序状态字寄存器PSW](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#iRNeNWWoGmXMv4PiHBJX3u "程序状态字寄存器PSW")、[堆栈指针SP](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#kKeddJu5j26C5qHNYZMq9p "堆栈指针SP")、[数据指针DPTR](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#h3VEFQq4kpKBnDjxxC81Td "数据指针DPTR")

**二、80C51的片内存储器**

在物理上设计成程序存储器和数据存储器两个独立的空间（称为哈佛结构）：

* 内部ROM容量4K字节范围是：0000H\~0FFFH

* 内部RAM容量128字节范围是：00H\~7FH

**三、80C51的I/O口及功能单元**

* 四个8位的并行口，即P0\~P3。它们均为双向口，既可作为输入，又可作为输出。每个口各有8条I/O线。

* 有一个全双工的串行口（利用P3口的两个引脚P3.0和P3.1）；

* 有2个16位的定时/计数器 ；

* 有1套完善的中断系统。 &#x20;

**四、80C51的特殊功能寄存器（SFR）**

* 内部有SP，DPTR（可分成DPH、DPL两个8位寄存器），PCON，…，IE，IP等21个特殊功能寄存器单元，它们同内部RAM的128个字节统一编址，地址范围是80H～FFH。这些SFR只用到了80H～FFH中的21个字节单元，且这些单元是离散分布的。

**五、80C51的时钟产生方式**

![](/image/image_AsJZ9j-r4G.png)

[分频器](https://www.wolai.com/ekFCFFRf16f92GT2jHmMfj#b1uz7YLYcwJRt4SDHtNcta "分频器")

![](/image/image_DW0WPCbjVj.png)

### 2.4.2 时钟结构

**单周期指令时序**

![](/image/image_8IU1BbyRJ3.png)

**双周期指令时序**

![](/image/image_IGlaBt_vNW.png)

\*\*访问外部RAM的双周期指令时序&#x20;
\*\*

![](/image/image_0o0fxX0jQt.png)

### 2.4.3 复位电路

复位的目的是使单片机或系统中的其他部件处于某种确定的初始状态。

![](/image/image_ePH01-6b-l.png)

**单片机复位后的状态**

PC=0000H，所以程序从0000H地址单元开始执行；

启动后，片内RAM为随机值，运行中的复位操作不改变片内RAM的内容 ；

PSEN、ALE、四个并口引脚高电平

![](/image/image_0I3ZTzvIAy.png)

## 2.5 80C51的存储器组织&#x20;

* [RAM](https://www.wolai.com/gem1iFM2jCJRLfFDPjCYJH#x7kTs9XkdE7bboMa2vMKxX "RAM")

    CPU在运行时能随时进行数据的写入和读出，但在关闭电源时，其所存储的信息将丢失。它用来存放暂时性的输入输出数据、运算的中间结果或用作堆栈。

* [ROM](https://www.wolai.com/gem1iFM2jCJRLfFDPjCYJH#n9XyU8DJMFs6Y9PxUma7Wf "ROM")

    是一种写入信息后不易改写的存储器。断电后，ROM中的信息保留不变。用来存放固定的程序或数据，如系统监控程序、常数表格等。&#x20;

### 2.5.1 程序存储器配置

![](/image/image_-mxlqOoGvK.png)

### 2.5.2 数据存储器配置

![](/image/image_lm7QG4gkSe.png)

**工作寄存器**

&#x20;      低端32个字节分成4个工作寄存器组，每组8个单元。当前工作寄存器组的机制便于快速现场保护。&#x20;

![](/image/image__1Bz8StGJU.png)

[PSW](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#rHpR8f33DYwCtYmvq1pz69 "PSW")的RS1、RS0决定当前工作寄存器组号

**位寻址**

![](/image/image_PKtRZrk-zl.png)

**通用RAM区**

* 位寻址区之后的30H至7FH共80个字节为通用RAM区。这些单元可以作为数据缓冲器使用。这一区域的操作指令非常丰富，数据处理方便灵活。

* 在实际应用中，常需在RAM区设置堆栈。80C51的堆栈一般设在30H\~7FH的范围内。栈顶的位置由SP寄存器指示。复位时SP的初值为07H，在系统初始化时可以重新设置

### 2.5.3 特殊功能寄存器（SFR）

![](/image/image_XR0jB8Zm04.png)

#### 运算寄存器

* 累加器ACC，8位。用于向ALU提供操作数，许多运算的结果也存放在累加器中；

* 寄存器B，8位。主要用于乘、除法运算。也可以作为RAM的一个单元使用；

* 程序状态字寄存器PSW，8位。其各位含义为：

    ![](/image/image_rzQoDrQdPD.png)

  * CY：进位、借位标志。有进位、借位时 CY=1，否则CY=0；最高位是否进位

        进位标志。在执行某些算术和逻辑指令时，它可以被硬件或软件置位或清零。CY在布尔处理机中被认为是位累加器，其重要性相当于一般中央处理器中的累加器A。

  * AC：辅助进位、借位标志；high-low之间是否存在进位3位是否进位到4位

        辅助进位标志。当进行加法或减法操作而产生由低4位数向高4位数进位或借位时，AC将被硬件置位，否则就被清零。AC被用于BCD码调整，详见指令系统中的“DA  A”指令

  * F0：用户标志位，由用户自己定义；

        用户标志位。F0是用户定义的一个状态标记，用软件来使它置位或清零。该标志位状态一经设定，可由软件测试F0，以控制程序的流向。

  * RS1、RS0：当前工作寄存器组选择位；

        寄存器区选择控制位。可以用软件来置位或清零以确定工作寄存器区。RS1、RS0与寄存器区的对应关系见表2-2。

  * OV：溢出标志位。有溢出时OV=1，否则OV=0；最高位和次高位有且只有一个进位等于1

        溢出标志。当执行算术指令时，由硬件置位或清零，以指示溢出状态。当执行加法指令ADD，位6向位7有进位而位7不向CY进位，或位6不向位7进位而位7向CY进位时，溢出标志OV置位，否则清零。

        溢出标志常用于ADD和SUBB指令对带符号数作加、减运算时，OV = 1表示加、减运算的结果超出了目的寄存器A所能表示的带符号数(2的补码)的范围(-128～+127)，参见第3章指令系统中关于ADD和SUBB指令的说明。

        在MCS-51中，无符号数乘法指令MUL的执行结果也会影响溢出标志。若置于累加器A和寄存器B的两个数的乘积超过255时，OV = 1，否则OV = 0。此积的高8位放在B内，低8位放在A内。因此，OV=0意味着只要从A中取得乘积即可，否则要从A、B寄存器对中取得乘积。 &#x20;
        　　除法指令DIV也会影响溢出标志。当除数为0时，OV = 1，否则OV = 0。

  * P：奇偶标志位。ACC中结果有奇数个1时P=1，否则 P=0。

        奇偶标志。每个指令周期都由硬件来置位或清零，以表示累加器A中1的位数的奇偶数。若1的位数为奇数，P置1，否则P清零。 &#x20;
        　　P标志位对串行通信中的数据传输有重要的意义，在串行通信中常用奇偶校验的办法来检验数据传输的可靠性。在发送端可根据P的值对数据进行奇偶置位或清零。

#### 指针类寄存器

* 堆栈指针SP，8位。它总是指向栈顶。

    堆栈操作遵循“后进先出”的原则，入栈操作时，SP先加1，数据再压入SP指向的单元。出栈操作时， 先将SP指向的单元的数据弹出，然后，SP再减1，这时SP指向的单元是新的栈顶。可见，80C51单片机的堆栈区是向地址增大的方向生成的。

* 数据指针DPTR，16位。用来存放16位的地址。

    它由两个8位的寄存器DPH和DPL组成。间接寻址或变址寻址可访问**片外**的64KB范围的RAM或ROM数据。&#x20;

    DPH是其高位字节寄存器，DPL是其低位字节寄存器，DPTR既可以作为一个16位的寄存器来处理，也可以作为两个独立的8位寄存器来使用

#### 端口相关的寄存器

* 并行I/O口P0、P1、P2、P3，均为8位

* 串行口数据缓冲器SBUF；串行口控制寄存器SCON；串行通讯波特率倍增寄存器PCON（一些位还与电源控制相关，所以又称为电源控制寄存器）。

#### 中断与定时寄存器

* 中断允许控制寄存器IE；

* 中断优先级控制寄存器IP。

* 定时/计数器T0的两个8位计数初值寄存器TH0、TL0，它们可以构成16位的计数器，TH0存放高8位，TL0存放低8位；

* 定时/计数器T1的两个8位计数初值寄存器TH1、TL1，它们可以构成16位的计数器，TH1存放高8位，TL1存放低8位；

* 定时/计数器的工作方式寄存器TMOD；

* 定时/计数器的控制寄存器TCON。

# 3. MCS-51单片机指令系统和汇编语言程序示例

## 3.1指令系统概述

### 3.1.1 指令、指令系统的概念

指令---是CPU按照人们的意图来完成某种操作的命令，它以英文名称或缩写形式作为助记符。

汇编语言指令---用助记符、符号地址、标号等表示的书写程序的语言。

掌握汇编语言指令是程序设计的基础。

**指令系统概述**

简明、易掌握、效率较高的指令系统，复杂指令集。

按所占字节分，分三种：

1. 单字节指令49条；

2. 双字节指令45条；

3. 三字节指令17条。

按执行时间来分，分三种：

1. 1个机器周期（12个时钟振荡周期）的指令64条；

2. 2个机器周期指令45条；

3. 4个机器周期——乘、除指令。

### 3.1.2 51单片机指令系统及其指令格式

指令系统中的指令描述了不同的操作，不同操作对应不同的指令。

每条指令通常由操作码和操作数两部分组成。

操作码表示计算机执行该指令将进行何种操作，操作数表示参加操作的数的本身或操作数所在的地址。

MCS-51单片机的指令有无操作数、单操作数、双操作数三种情况。汇编语言指令有如下的格式：

`[标号：]操作码助记符[目的操作数][，源操作数] [；注释]`

[**一些符号的约定意义说明**](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#9d98iL2G2Jac8x35VC7Ufc "一些符号的约定意义说明")**：**

1. Ri和Rn：表示当前工作寄存器区中的工作寄存器，i取0或1，表示R0或R1,只有这两个寄存器可以存放地址。n取0\~7，表示R0\~R7。

2. &#x20;\#data：表示包含在指令中的8位立即数。

3. \#data16：表示包含在指令中的16位立即数。

4. &#x20;rel：以补码形式表示的8位相对偏移量，范围为-128\~127，主要用在相对寻址的指令中。

5. addr16和addr11：分别表示16位直接地址和11位直接地址。

6. direct：表示直接寻址的地址。片内RAM低128字节(00H–7FH)、特殊功能寄存器

7. bit：表示可位寻址的直接位地址。

8. (X)：表示X单元中的内容。

9. ((X))：表示以X单元的内容为地址的存储器单元内容，即(X)作地址，该地址单元的内容用((X))表示。

10. &#x20;/ 和→符号：“/”表示对该位操作数取反，但不影响该位的原值。“→”表示操作流程，将箭尾一方的内容送入箭头所指另一方的单元中去

## 3.2 51的寻址方式

寻址方式：寻找（源）操作数或指令转移地址的方式

80C51单片机有7种寻址方式

### 3.2.1 寄存器寻址

$ ~~~~~~~~~~~~~(R_0)=30H
\\执行~~~~~\color{blue}MOV ~~~~A, R_0\color{black} 后
\\~~~~~~~~~~~~~(A)=30H  $

![](/image/image_Cir1dpFr3M.png)

操作数在寄存器中,寻址空间:[R0\~R7](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#otBUCt18u1ftGT4ZkXLeiM "R0\~R7")、A、B和[DPTR](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#h3VEFQq4kpKBnDjxxC81Td "DPTR")

特点：传送和执行速度快

### 3.2.2 直接寻址

$ 若~~~~~~~~~~~~~~(50H)=3AH
\\执行~~~~~~~~~~~~\color{blue}MOV ~~~~ A,50H\color{black}~~~
\\后~~~~~~~~~~~~~~~~~~~(A)=3AH  $

![](/image/image_JalmWcXstC.png)

操作码后字节存放的是操作数的地址

寻址空间: 片内RAM低128字节[SFR](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#3hFWz2YsHsCQJJrdR3bi2t "SFR")

另一类直接寻址是转移目标地址的寻址。如

$\color{blue}
LJMP ~~~~~ADDR16$

LJMP长转移指令的功能是：把指令码中的目标地址addr16装入[程序计数器PC](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#uv5d1u4C4f745htS3hbd61 "程序计数器PC")，使机器执行下一条指令时无条件转移到addr16处执行程序，不影响任何标志。

### 3.2.3 寄存器间接寻址

$若~~~~~~~~~~(R_0)=30H,(30H)=5AH
\\执行~~~~~~\color{blue}MOV~~~A,@R_0 \color{black}
\\后~~~~~~~~~~(A)=5AH$

![](/image/image_L47kZzCXKA.png)

寄存器中的内容是操作数的地址

寻址空间:片内RAM（@$R_i$、[SP](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#kKeddJu5j26C5qHNYZMq9p "SP")）,片外RAM（@Ri、@[DPTR](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#h3VEFQq4kpKBnDjxxC81Td "DPTR")）

片内移动:MOV

片外移动:MOVX

### 3.2.4 立即寻址

$执行~~~~\color{blue}MOV~~~~A,\#50H
\\\color{black}  后~~~~~~~~(A)=50H$

![](/image/image_K-_2Cx1Q_D.png)

操作数在指令编码中

寻址空间:ROM

对于MOV DPTR，#2100H指令，立即数高8位“21H”装入DPH &#x20;

### 3.2.5 变址寻址

$ 定义~~~~(A)=0FH,(DPTR)=240FH
\\执行 ~~~~\color{blue}MOVC ~~~~A,@A+DPTR
\\\color{black}后~~~~~~~~(A)=88H  $

![](/image/image_W7oXvEKf3c.png)

操作数地址:基地址+偏移量

寻址空间:ROM

变址寻址还用于跳转指令，如JMP  @A+DPTR  &#x20;

### 3.2.6 相对寻址

用于跳转指令，实现程序分支

【例】若rel为75H，PSW\.7为1，JC  rel存于1000H开始的单元。&#x20;

执行JC  rel指令后，程序将跳转到1077H单元取指令并执行。&#x20;

![](/image/image_GVQMhEYC3X.png)

Rel常用符号地址表示，离源地址不要超过（－128～＋127 ）  &#x20;

### 3.2.7 位寻址                         &#x20;

![](/image/image_O9BxUtjWRL.png)

### 3.2.8总结

| 序号 | 寻址方式    | 寻址空间                    |   |
| -- | ------- | ----------------------- | - |
| 1  | 寄存器寻址   | \$ R\_0～R\_7、A、B、C、DPTR |   |
| \$ |         |                         |   |
| 2  | 直接寻址    | 内部128字节RAM、特殊功能寄存器      |   |
| 3  | 寄存器间接寻址 | 片内数据存储器、片外数据存储器         |   |
| 4  | 立即数寻址   | 程序存储器中的立即数              |   |
| 5  | 变址寻址    | 读程序存储器固定数据和程序散转         |   |
| 6  | 相对寻址    | 程序存储器相对转移               |   |
| 7  | 位寻址     | 内部RAM中的可寻址位、SRF中的可寻址位   |   |

## 3.3 数据传送类指令

一般不影响标志寄存器PSW的状态。

* 一般传送指令：MOV

    1. 十六位传送

        `MOV DPTR, #data16;`      DPTR ← data16

        例如：执行指令MOV DPTR，#1234H 后（DPH）=12H，（DPL）=34H

    2. 八位传送

        `MOV <目的字节>，<源字节>;`

* 特殊传送指令：MOVC、MOVX、PUSH/POP、XCH/XCHD、SWAP

### 3.3.1 一般指令传送

#### 1. 以A为目的(累加器)

![](/image/image_FHq2lSFqNt.png)

【例】若（$R_1$）=20H，（20H）=55H。执行指令`MOV A,@R1` 后，（A）=55H。

#### 2. 以R\_n为目的

![](/image/image_CbMQRdSXkW.png)

【例】执行指令`MOV  R6，#50H` 后($ R_6
  $)= 50H&#x20;

#### 3. 以direct为目的

![](/image/image_yndp6C4mx8.png)

【例】若（R1）=50H,（50H）=18H，执行指`MOV 40H，@R1`后,（40H）=18H

#### 4. 以@R\_i为目的

![](/image/image_Z5JUj7bjzA.png)

【例】若（R1）=30H，（A）=20H，执行指令`MOV @R1，A` 后，（30H）=20H。

### 3.3.2 特殊传送指令

#### 1.读ROM中常数表项指令MOVC

ROM中可以存放程序代码，还经常存放常数表&#x20;

* 以DPTR内容为基址

    常数表存放约束小，称为远程查表指令.占用DPTR&#x20;
    `MOVC  A，@A+DPTR；A ←（（A）+（DPTR））`

* 以PC内容为基址

    常数表存放约束大，称为近程查表指令.不占用DPTR&#x20;

    `MOVC  A，@A+PC  ；A ←（（A）+（PC））`

#### 2.读片外RAM及接口单元数据的指令MOVX&#xD;

![](/image/image_At3rRvXpME.png)

#### 3. 堆栈操作指令PUSH和POP&#xD;

![](/image/image_W2w2JyqzvM.png)

![](/image/image_2xYlew4Vpb.png)

#### 4.数据交换指令XCH、XCHD和SWAP&#xD;

![](/image/image_cML2BySKkY.png)

![](/image/image_Xb_hNh76U2.png)

## 3.4 算术运算类指令

#### 3.4.1 加、减法指令

![](/image/image_01_WyvA2pf.png)

![](/image/image_tTd6S99hJQ.png)

例6  设(A) = 49H，(R0)=6BH，分析执行指令ADD A，R0后的结果。

$49H~\rarr0100~~1001~B
\\6BH\rarr0110~~1011~B
\\——————————
\\ B4H\larr      \color{red}1\color{black}01\color{red}1\color{black}~~0100 ~B$

[结果为：(A)=B4H，OV=1，CY=0，AC=1，P=0。](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#dmvrcGbVr1YRakpr8Kxdjd "结果为：(A)=B4H，OV=1，CY=0，AC=1，P=0。")

例7  设(A)=C3H，数据指针低(DPL)=ABH，CY=1，分析执行指令ADDC A，DPL后的结果。

结果为：(A)=6FH，CY=1，AC=0，P=0

例8 设 (A) = 52H，(R0)=B4H，分析执行如下指令后的结果

CLRC ；是位操作指令，是进位位清零

SUBB  A，R0

结果为：(A)=9EH，CY=1，AC=1，OV=1，P=1

例9  设 (R0) = 7EH，(7EH)=FFH，(7FH)=38H，(DPTR)=10FEH，分析逐条执行下列指令后各单元的内容

INC @R0 ；使7EH单元内容由FFH变为00H

INC R0 ；使R0的内容由7EH变为7FH

INC @R0 ；使7FH单元内容由38H变为39H

INC DPTR ；使DPL为FFH，DPH不变

INC DPTR ；使DPL为00H，DPH为11H

INC DPTR ；使DPL为01H，DPH不变

### 3.4.2  十进制调整指令&#xD;

在计算机中，十进制数字0\~9一般可用[BCD码](https://baike.baidu.com/item/BCD码 "BCD码")来表示，然而计算机在进行运算时，是按二进制规则进行的，对于4位二进制数有16种状态，对应1 6个数字，而十进制数只用其中的10种表示0～9，因此按[二进制](https://baike.baidu.com/item/二进制 "二进制")的规则运算就可能导致错误的结果.

![](/image/image_46zLP-CDaZ.png)

若[AC=1，CY=1](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#dmvrcGbVr1YRakpr8Kxdjd "AC=1，CY=1")同时发生，或者高4位虽等于9但低4位修正后有进位，则A应加66H修正。

十进制调整指令是一条对二-十进制的加法进行调整的指令。它是一条单字节指令，机器码为D4H。两个压缩BCD码按二进制相加，必须在加法指令ADD、ADDC后，经过本指令调整后才能得到正确的压缩BCD码和数，实现十进制的加法运算。

例10 .对BCD码加法65 + 58→BDH，进行十进制调整。

`MOV A，#65H ;`(A)←65

`ADD A，#58H；`(A)←(A)+58

`DA A ；`十进制调整

![](/image/image_DDAzVP25kz.png)

例11  设片内RAM 30H，31H单元中分别存放着两位BCD码表示的被减数和减数，两数相减的差仍以BCD码的形式存放在32H单元中。可用下面的程序实现：

`CLR C`

`MOV   A，#9AH;`

`SUBB  A，31H；`求减数的十进制补码

`ADD  A，30H；`作十进制补码加法

`DA  A；`进行BCD调整

`MOV  32H，A；`将BCD码的差送存32H单元

### 3.4.3 乘、除法指令

1. 乘法

    ![](/image/image_x48wKa9i9f.png)

    乘法指令的功能是把累加器A和寄存器B中的两个8位无符号数相乘，将乘积16位数中的低8位存放在A中，高8位存放在B中。若乘积大于FFH(255)，则溢出标志OV置1，否则OV清零。乘法指令执行后进位标志CY总是零，即CY=0。

2. 除法

    ![](/image/image_YNw2v0VdKI.png)

    除法指令的功能是把累加器A中的8位无符号整数除以寄存器B中的8位无符号整数，所得商存于累加器A中，余数存于寄存器B中，进位标志位CY和溢出标志位OV均被清零。若B中的内容为0时，溢出标志OV被置1，即OV=1，而CY仍为0。

## 3.5 逻辑运算与循环类指令

逻辑运算指令可以完成与、或、异或、清0和取反操作，当以累加器A为目的操作数时，对P标志有影响；

循环指令是对累加器A的循环移位操作，包括左、右方向以及带与不带进位位等移位方式，移位操作时，带进位的循环移位对CY和P标志有影响；

累加器清0操作对P标志有影响。&#x20;

![](/image/image_r0JZUZPWke.png)

![](/image/image_Cg0KaX5Y4T.png)

![](/image/image_yhd0PD1Ky8.png)

![](/image/image_Zyg-aZW6ms.png)

### 3.5.1 逻辑与

![](/image/image_dgCeUoljnQ.png)

![](/image/image_G-9cg7MkZF.png)

前2条指令的功能是把源操作数与直接地址指示的单元内容相与，结果送入直接地址指示的单元。

后4条指令的功能是把源操作数与累加器A的内容相与，结果送入累加器A中。

例  若（A）=C3H，（R0）=AAH，执行指令  ANL  A，R0 之后，（A）=82H。

### 3.5.2 逻辑或

![](/image/image_MsFbde57xE.png)

![](/image/image_D6se__JxZL.png)

前2条指令的功能是把源操作数与直接地址指示的单元内容相或，结果送入直接地址指示的单元。

后4条指令的功能是把源操作数与累加器A的内容相或，结果送入累加器A中

例  若（A）=C3H，（R0）=55H，执行指令ORL  A，R0 之后，（A）=D7H

### 3.5.3 逻辑异或

![](/image/image_PZgRLCbsqm.png)

![](/image/image_EMbNMKYsoC.png)

前2条指令的功能是把源操作数与直接地址指示的单元内容异或，结果送入直接地址指示的单元。

后4条指令的功能是把源操作数与累加器A的内容异或，结果送入累加器A中。

例  若（A）=C3H，（R0）=AAH，执行指令  XRL  A，R0 之后，（A）=69H。

### 3.5.4 累加器清0和取反

![](/image/image_KEq31nRYKk.png)

这两条指令的功能分别是把累加器A的内容清 0 和取反，结果仍在A中

例   若（A）=A5H，执行指令  CLR  A 之后，（A）=00H。        &#x20;

### 3.5.5 累加器循环移位

![](/image/image_QytPK4w8g7.png)

![](/image/image_a17yBhKfiJ.png)

&#x20;   有时“累加器A内容乘2”的任务可以利用指令RLC  A方便地完成。

&#x20;例：若（A）= BDH = 1011 1101B，（CY）＝0。执行指令RLC  A后，（CY）=1，（A）= 0111 1010B = 7AH，（CY）＝1

### 例题

![](/image/image_zCult9Woc_.png)

![](/image/image_IcF3IMC0wL.png)

![](/image/image_TiS3F295Ue.png)

![](/image/image_6ZZGQDhHJF.png)

## 3.6 控制转移类指令

![](/image/image_OG5gIZALOT.png)

### 3.6.1 无条件转移指令

#### 1.LJMP(长转指令)

把指令码中的目标地址addr16装入程序计数器PC，使机器执行下一条指令时无条件转移到addr16处执行程序，不影响任何标志。

LJMP指令执行后，程序无条件地转向16位目标地(addr16)处执行，不影响标志位。由于指令中提供16位目标地址，所以执行这条指令可以使程序从当前地址转移到64 KB程序存储器地址空间的任意地址，故得名为"长转移"。该指令的缺点是执行时间长，字节多。

#### 2. AJMP(绝对转移指令)

AJMP主要是用来改变程序执行的路线，到需要的指令或程序去执行

AJMP的机器码是由11位直接地址addr11和指令操作码00001，按下列分布组成的：

![](/image/image_mM55lpo9NN.png)

该指令执行后，程序转移的目的地址是由AJMP指令所在位置的地址PC值加上该指令字节数2，构成当前PC值。取当前PC值的高5位与指令中提供的11位直接地址形成转移的目的地址，即&#x20;

![](/image/image_Sjk4v7QdQ5.png)

AJMP addr11 ； PC←（PC）+2，

&#x20;                        ； PC10\~0← addr11

该指令执行时，先将PC的内容加2（这是PC指向的是AJMP的下一条指令），然后把指令中11位地址码传送到PC10\~0，而PC15\~11保持原内容不变。

在目标地址的11位中，前3位为页地址，后8位为页内地址（每页含256个单元）。

#### 3. SJMP(相对短转指令）

指令的操作数rel用8位带符号数补码表示，占指令的一个字节。因为8位补码的取值范围为-128\~+127，所以该指令的转移范围是：相对PC当前值向前转128字节，向后转127字节。即

转移目的地址=SJMP指令所在地址+2+rel

如在2100H单元有SJMP指令，若rel= 5AH(正数)，则转移目的地址为215CH(向后转)；若rel= F0H(负数)，则转移目的地址为20F2H(向前转)。

#### 4．JMP @A+DPTR(相对长转移指令)

它是以数据指针DPTR的内容为基址，以累加器A的内容为相对偏移量，在64 KB范围内无条件转移。该指令的特点是转移地址可以在程序运行中加以改变。例如，当DPTR为确定值，根据A的不同值就可以实现多分支的转移。该指令在执行后不会改变DPTR及A中原来的内容。

### 3.6.2 条件转移指令

条件转移指令是当某种条件满足时，程序转移执行；条件不满足时，程序仍按原来顺序执行。转移的条件可以是上一条指令或更前一条指令的执行结果(常体现在标志位上)，也可以是条件转移指令本身包含的某种运算结果。由于该类指令采用相对寻址，因此程序可在以当前PC值为中心的-128～+127范围内转移。该类指令共有8条，可以分为累加器判零条件转移指令、比较条件转移指令和减1条件转移指令三类。表3.5中列出了这些指令

![](/image/image_PdMHOcocLE.png)

#### 1.判零条件转移指令

判零条件转移指令以累加器A的内容是否为0作为转移的条件。

JZ指令是为0转移，不为0则顺序执行；

JNZ指令是不为0转移，为0则顺序执行。

累加器A的内容是否为0，是由这条指令以前的其它指令执行的结果决定的，执行这条指令不作任何运算，也不影响标志位。

例17  将片外RAM首地址为DATA1的一个数据块转送到片内RAM首地址为DATA2的存储区中。

> 外部RAM向内部RAM的数据转送一定要经过累加器A，利用判零条件转移正好可以判别是否要继续传送或者终止。完成数据传送的参考程序如下：

```6502&#x20;assembly
       MOV  R0,#DATA      ；R0作为外部数据块的地址指针
       MOV  R1,#DATA2     ；R1作为内部数据块的地址指针
LOOP： MOVX  A,@R0        ；取外部RAM数据送入A
HERE： JZ  HERE           ；数据为零则终止传送
       MOV  @R1, A     ；数据传送至内部RAM 单元
       INC  R0         ；修改指针，指向下一数据地址
       INC  R1
       SJMP  LOOP      ；循环取数
```

#### 2.比较转移指令CJNE

比较转移指令共有4条。这组指令是先对两个规定的操作数进行比较，根据比较的结果来决定是否转移。

若两个操作数相等，则不转移，程序顺序执行；

若两个操作数不等，则转移。

比较是进行一次减法运算，但其差值不保存，两个数的原值不受影响，而标志位要受到影响。利用标志位CY作进一步的判断，可实现三分支转移。

例18  当从P1口输入数据为01H 时，程序继续执行，否则等待，直到P1口出现01H。参考程序如下：

```6502&#x20;assembly
MOV  A，#01H                ；立即数01H送A
WAIT： CJNE  A，P1，WAIT     ；(P1)≠01H，则等待

```

#### 3.减1条件转移指令

减1条件转移指令有两条。每执行一次这种指令，就把第一操作数减1，并把结果仍保存在第一操作数中，然后判断是否为零。若不为零，则转移到指定的地址单元，否则顺序执行。

这组指令对于构成循环程序是十分有用的，可以指定任何一个工作寄存器或者内部RAM单元作为循环计数器。

每循环一次，这种指令被执行一次，计数器就减1。预定的循环次数不到，计数器不会为0，转移执行循环操作；到达预定的循环次数，计数器就被减为0，顺序执行下一条指令，也就结束了循环。

例19  将内部RAM从DATA单元开始的10个无符号数相加，相加结果送SUM单元保存,设相加结果不超过8位二进制数，则相应的程序如下：

```6502&#x20;assembly
        MOV  R0，#0AH      ；设置循环次数
        MOV  R1，#DATA     ；R1作地址指针，指向数据块首地址
        CLR  A             ；A清零
 LOOP： ADD  A，@R1         ；加一个数
        INC  R1             ；修改指针，指向下一个数
        DJNZ  R0，LOOP     ；R0减1，不为0循环
        MOV  SUM，A        ；存10个数相加的和

```

## 3.7 子程序调用与返回指令

### 3.7.1 子程序调用指令

子程序调用指令有长调用和绝对调用两条，它们都是双周期指令.

![](/image/image_yVOT2HErjg.png)

![](/image/image_ZVnvFIrfUj.png)

这两条指令可以实现子程序的短调用和长调用。目标地址的形成方式与[AJMP](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#qLHPCW9YQYtbFxe6q8NJVM "AJMP")和LJMP相似。这两条指令的执行不影响任何标志。&#x20;

* ACALL指令执行时，被调用的子程序的首址必须设在包含当前指令（即调用指令的下一条指令）的第一个字节在内的2K字节范围内的程序存储器中.

* LCALL指令执行时，被调用的子程序的首址可以设在64K字节范围内的程序存储器空间的任何位置。

&#x20;例   若（SP）=07H，标号“XADD”表示的实际地址为0345H，PC的当前值为0123H。执行指令 ACALL XADD 后，（PC）+2=0125H，其低8位的25H压入堆栈的08H单元，其高8位的01H压入堆栈的09H单元。（PC）=0345H，程序转向目标地址0345H 处执行。

LCALL和ACALL指令类似于转移指令LJMP和AJMP，不同之处在于它们在转移前要把执行完该指令的PC内容自动压入堆栈后，才将子程序入口地址addr16(或addr11)送PC，实现转移。

* LCALL与LJMP一样提供16位地址，可调用64 KB范围内的子程序。

    由于该指令为3字节，所以执行该指令时首先应执行(PC)←(PC)+3，以获得下一条指令地址，并把此时的PC内容压入堆栈(先压入低字节，后压入高字节)作为返回地址，堆栈指针SP加2指向栈顶，然后把目的地址addr16送入PC。该指令执行不影响标志位。

* ACALL与AJMP一样提供11位地址，只能调用与PC在同一2 KB范围内的子程序。

    由于该指令为2字节指令，所以执行该指令时应执行(PC)←(PC)+2以获得下一条指令地址，并把该地址压入堆栈作为返回地址。该指令机器码的构成也与AJMP类似，只不过操作码第一字节其高半字节的最后一位是1，机器码的组成如下：

    ![](/image/image_H3wlFaqMve.png)

### 3.7.2 返回指令

返回指令共两条：

一条是对应两条调用指令的子程序返回指令RET，

另一条是对应从中断服务程序的返回指令RETI.

![](/image/image_492dKTjoEw.png)

从上述两条指令的功能操作看，都是从堆栈中弹出返回地址送PC，堆栈指针减2，但它们是两条不同的指令。其有下面两点不同：

1. 从使用上，RET指令必须作子程序的最后一条指令；RETI必须作中断服务程序的最后一条指令。

2. RETI指令除恢复断点地址外，还恢复CPU响应中断时硬件自动保护的现场信息。执行RETI指令后，将清除中断响应时所置位的优先级状态触发器，使得已申请的同级或低级中断申请可以响应；而RET指令只能恢复返回地址。

### 3.7.3 空操作指令

```6502&#x20;assembly
NOP   ；(PC)←(PC)+1

```

空操作指令是一条单字节单周期指令。它控制 CPU不做任何操作，仅仅是消耗这条指令执行所需要的一个机器周期的时间，不影响任何标志位，故称为空操作指令。NOP指令在设计延时程序、拼凑精确延时时间及在程序等待或修改程序等场合是很有用的。

## 3.8 位操作类指令

位操作类指令在单片机指令系统中占有重要地位,这是因为单片机在控制系统中主要用于控制线路通、断，继电器的吸合与释放等。

位操作也称布尔变量操作，它是以位(bit)作为单位来进行运算和操作的。MCS-51单片机内部有一个功能相对独立的布尔处理机，它有借用进位标志CY作为位累加器，有位存储器(即位寻址区中的各位)，指令系统中有17条专门进行位处理的指令集。位处理指令可以完成以位为对象的数据传送、运算、控制转移等操作。

在位操作指令中，位地址的表示有以下不同的方法(以下均以程序状态字寄存器PSW的第5位F0标志为例说明)：

1. 直接位地址表示，如D5H。

2. 点表示(说明是什么寄存器的什么位)，如PSW\.5，说明是PSW的第5位。

3. 位名称表示，如直接用F0表示。

4. 用户定义名称表示，如用户定义用FLG这一名称来代替F0，则在指令中允许用FLG表示F0标志位。

![](/image/image_SwVxK8Q3Ar.png)

例20  利用位操作指令，模拟图3.6所示硬件逻辑电路的功能。参考程序如下：

```6502&#x20;assembly
PR2：  MOV  C,P1.1        ；(CY)← (P1.1)
       ORL  C,P1.2        ；(CY)← (P1.1) ∨(P1.2)=A
       ANL  C,P1.0        ；(CY)←(P1.0)∧A
       CPL  C             ；(CY)←(P1.0)∧A=B 
       MOV  F0,C          ；F0内暂存B
       MOV  C,P1.3        ；(CY)←(P1.3)
       ANL  C,/P1.4       ；(CY)←(P1.3)∧(P1.4)=D
       ORL  C,F0          ；(CY)←B∨D
       MOV  P1.5,C        ；运算结果送入P1.5
       RET

```

![](/image/image_E7HzmCrik-.png)

# 4. 汇编语言程序设计

## 4.1 伪指令

伪指令也称指示性语句，无机器码，供汇编程序识别和执行的命令，对机器汇编进行控制。

MCS-51的伪指令共8条

1. ORG:起始汇编伪指令，用于汇编源程序或数据块的开头。

    ```6502&#x20;assembly
    [标号]:ORG, addr16
           ORG, 0110H. 
           START:MOV A,#64H
           ...
           END
    ```

2. END结束汇编伪指令

    END只能放在程序末

3. EQU:赋值伪指令

    ```6502&#x20;assembly
    字符名称   EQU    数据或汇编符（8位、16位 、寄存器名）   

    ```

    EQU 中的字符需要先赋值后使用，一般放在程序的开头。

    ```6502&#x20;assembly
    AA   EQU  R1
    M    EQU  30H
    MOV  A    M
    ```

4. DATA:数据地址赋值

    ```6502&#x20;assembly
    字符     DATA     表达式
    ```

    与EQU类似，将表达式的值赋给符号，表达式可以是数据或地址，也可以是含字符号的表达式，不能是汇编符  R0\~R7

5. DB :定义字节,在内存的某个区域定义一个或一串字节。

    ```6502&#x20;assembly
    标号：DB     项或项表
    ORG    1000H
    TABLE: DB  01H,04H,09H,10H,19H,24H

    ```

    ![](/image/image_9XPOHyT7Bl.png)

6. DW :定义字，内存的某个区域定义一个或一串字.

    1dw的长度为2db，即16位，两个字节。（DW定义16位数据，每个数据需两个单元存放。高8位数据字节先存入低地址字节中，而低8位数据字节则再存入高地址字节中。）

    ```6502&#x20;assembly
    标号：DW     项或项表
    ORG   1000H
    HAT  :  DW  1234H,78H,09H,10
    END

    ```

    ![](/image/image_47BqzgIW6Y.png)

7. DS  :定义存储空间伪指令

    ```6502&#x20;assembly
    [标号]：DS   表达式  在内存中保留一定的空间
    ORG   0400H
    START :MOV  A，32H
    SPC :DS   08H ;从SPC地址开始留出8个字节 ，第9个字节存25H
    DB   25H
    END

    ```

8. BIT  :位地址

    字符名称     BIT     位地址

    ```6502&#x20;assembly
    ORG   0300H
    RESET     BIT     90H(P1.0)
    JNB    RESET，     DELAY
    DELAY:...
    END
    ```

## 4.2 分支循环程序

### 4.2.1 简单程序设计

简单程序:无转移指令、循序执行(直线执行)、程序简单

例：把20H单元内两个BCD数转换成相应的ASCII码，放在21H（高位BCD）和22H（低位BCD)

```6502&#x20;assembly
ORG 0500H
MOV R0,#22H 
MOV @R0,#00H
MOV A,20H
XCHD A,@R0       ;双半字节数据互换指令
ORL 22H,#30H     ;(22H) V 30H -> (22H)
SWAP A.          ;累加器高低四位互换
ADD A,#30H
MOV 21H,A
SJMP $            ;原地等待     
END

```

### 4.2.2 分支程序设计

程序中含有转移指令，包括条件分支和无条件分支，条件分支是满足条件则分支，具有分析和判断能力，应用较多，应掌握.

已知内部RAM  30H单元中，有一个自变量Ｘ，请按如下条件编出求函数值Ｙ并将它存入31H的程序

$ Y =\begin{cases}
1~~~~~~X>0
\\
0~~~~~~X=0
\\
-1~~~X<0
\end{cases}  $

```6502&#x20;assembly
      ORG 1000H
      MOV A,30H       ;将判断的数Y送给累加器
      JZ  DONE        ;指令为0跳转,否则不跳转
      JB  ACC.7 ,NEG  ;第7位1负数,0正数,负数跳转NEG
      MOV A,#01H  
      SJMP DONE
NEG:  MOV A,#0FFH     ;-1
DONE: MOV 31H,A
      SJMP $
      END

```

## 4.3 循环和查表程序设计

### 4.3.1 循环程序设计

程序中含有可重复执行的程序段,反复使用.

循环程序的构成:

1. 循环初始化:完成注本条件;循环次数的设定

2. 循环处理: 循环程序的工作程序

3. 循环控制:在循环体内,条件转移指令,判断循环是否结束

4. 循环结束: 存放循环所得的结果及恢复各单元的初值

例1：使用循环计算1-10的和

```6502&#x20;assembly
ORG 0000H
SUM EQU 30H   ;累加和保存的存储单元
MOV R2,#01H   ;加数，每次加法运算后加1
MOV R3,#00H   ;加法次数计数
MOV A,#00H    ;累加器初值0，进行累计并暂存结果
LOOP: ADD A,R2
      INC R2
      INC R3
      CJNE R3,#0AH,LOOP;判断是否达到10次加法
MOV SUM,A 
SJMP $
END

```

```6502&#x20;assembly
ORG 0000H
SUM EQU 30H   ;累加和保存的存储单元
ACALL SUMFUN
MOV SUM,A
SJMP $
SUMFUN:
    MOV R2,#01H   ;加数，每次加法运算后加1
    MOV R3,#0AH   ;加法总次数
    MOV A,#00H   ;累加器初值0，进行累计并暂存结果
LOOP:ADD A,R2
    INC R2
    DJNZ R3,LOOP;判断R3-1是否0
RET
END

```

例2:设有10组三字节被加数和加数，分别放在BLOCK1和BLOCK2为始址的两个数据块中，请编程求10组数的和（设和仍然为三字节），并把和放回从BLOCK1位起始地址的数据块中。

```6502&#x20;assembly
ORG 0500H
BLOCK1 DATA 20H
BLOCK2 DATA 40H
MOV R0,#BLOCK1.    ;被加数块始地址
MOV R1,#BLOCK2     ;加数块始地址
MOV R2,#0AH        ;加分组数
LOOP: MOV R3,#03H  ;加数字节
      CLR  C
      LOOP1: MOV  A, @R0   ;被加数送A
             ADDC A,@R1    ;加一个字节
             MOV  @R0,A    ;存和数字节
             INC  R0       ;修改被加数指针
             INC  R1       ;修改加数指针
      DJNZ R3,LOOP1        ;若一组未完,则转LOOP1
DJNZ R2,LOOP       ;若十组未完,则转LOOP
SJMP $
END
               
```

### 4.3.2 查表程序设计

根据存放在ROM中数据表格的项数来查找和它对应的表中值，常用指令:

1. `MOVC A,@A+DPTR`中DPTR为表头地址，A为项数

2. `MOVC A,@A+PC`中 A为项数，PC值需要调整，使得查表指令取出后的PC值加上修正量等于表头地址

R0的低四位有一个十六进制数0\~F中的 一个，编出能把它转换成相应ASCII码并送入R0的程序。

```6502&#x20;assembly
ORG  0400H
MOV  A,R0
MOV  DPTR,#0500H
ANL  A,#0FH
MOVC A,@A+DPTR
MOV  R0,A
ORG  0500H
DB  ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’ ,‘7’
DB  ‘8’, ‘9’, ‘A’, ‘B’, ‘C’, ‘D’ ,‘E’, ‘F’
END


```

![](/image/image_ciiGbNcAne.png)

## 4.4 定时器程序

#### 4.4.1 软件定时器

1. **单循环定时程序**

    ![](/image/image_gT88nJ_1au.png)

2. 较长时间的定时程序

    ![](/image/image_y0HbnWrfDz.png)

3. 提高定时精度

    有些指令无法实现精确定时,这时可调整某些指令来实现

    例：编出定时22$\mu
    s$的程序

    ![](/image/image_jlduTMnWtz.png)

    ![](/image/image_zyzqx1PAPN.png)

    晶振12M,计算延时时间

    ```6502&#x20;assembly
    T_0: MOV R7,#10 
    D1: MOV R6,#200 
    D2: MOV R5,#248 
           DJNZ R5,$ 
           DJNZ R6,D2 
           DJNZ R7,D1 
           RET
           
    ```

# 5 中断与定时器

[复习](https://www.wolai.com/7DF6svSbygH3hWAKEQ9NSy#anbQKJBGRtbqqUDFAnZPWz "复习")

## 5.1 80C51的中断系统

### 5.1.1 中断系统概述

CPU在处理某一事件A时，发生了另一事件B请求CPU迅速去处理（中断发生）；

CPU暂时中断当前的工作，转去处理事件B（中断响应和中断服务）；

待CPU将事件B处理完毕后，再回到原来事件A被中断的地方继续处理事件A（中断返回），这一过程称为中断 。

![](/image/image_JTUyAodEaJ.png)

引起CPU中断的根源，称为中断源。中断源向CPU提出的中断请求。CPU暂时中断原来的事务A，转去处理事件B。对事件B处理完毕后，再回到原来被中断的地方（即断点），称为中断返回。实现上述中断功能的部件称为中断系统（中断机构）。

随着计算机技术的应用，人们发现中断技术不仅解决了快速主机与慢速I/O设备的数据传送问题，而且还具有如下优点：

* **分时操作**。CPU可以分时为多个I/O设备服务，提高了计算机的利用率；

* **实时响应**。CPU能够及时处理应用系统的随机事件，系统的实时性大大增强；

* **可靠性高**。CPU具有处理设备故障及掉电等突发性事件能力，从而使系统可靠性提高。

### 5.1.2 80C51中断系统的结构

&#x20;   80C51的中断系统有5个中断源，2个优先级，可实现二级中断嵌套 。

![](/image/image_ssj0WI4nMm.png)

![](/image/image_eLcxSdsY2v.png)

1. RI（SCON.0）或TI（SCON.1），串行口中断请求标志。当串行口接收完一帧串行数据时置位RI或当串行口发送完一帧串行数据时置位TI，向CPU申请中断。&#x20;

* **中断源**

    1. $\overline {INT0}$（P3.2）。可由IT0(TCON.0)选择其为低电平有效还是下降沿有效。当CPU检测到P3.2引脚上出现有效的中断信号时，中断标志IE0(TCON.1)置1，向CPU申请中断。

    2. $ \overline {INT1}
          $（P3.3）。可由IT1(TCON.2)选择其为低电平有效还是下降沿有效。当CPU检测到P3.3引脚上出现有效的中断信号时，中断标志IE1(TCON.3)置1,向CPU申请中断。

    3. TF0（TCON.5），片内定时/计数器T0溢出中断请求标志。当定时/计数器T0发生溢出时，置位TF0，并向CPU申请中断。

    4. TF1（TCON.7），片内定时/计数器T1溢出中断请求标志。当定时/计数器T1发生溢出时，置位TF1，并向CPU申请中断。

* **中断请求标志**

    1. TCON的中断标志

        **TCON**：TCON在MCS51系列[单片机](https://www.eefocus.com/baike/505697 "单片机")中称为定时计数控制寄存器，所以主要和定时计数器有关，当然还可用来设置外部中断的触发方式。TCON（Timer Control Register）定时器/计数器控制寄存器 TCON在特殊功能寄存器中，字节地址为88H，位地址(由低位到高位)为88H一8FH，由于有位地址，十分便于进行位操作。 TCON的作用是控制定时器的启、停，标志定时器溢出和中断情况。

        ![](/image/image_XpYs1gqKQE.png)

        ![](/image/image_yzJYcU62Re.png)

        IT0（TCON.0），外部中断0触发方式控制位。

        当IT0=0时，为电平触发方式。

        当IT0=1时，为边沿触发方式（下降沿有效）。

        IE0（TCON.1），外部中断0中断请求标志位。

        IT1（TCON.2），外部中断1触发方式控制位。

        IE1（TCON.3），外部中断1中断请求标志位。

        TF0（TCON.5），定时/计数器T0溢出中断请求标志位。

        TF1（TCON.7），定时/计数器T1溢出中断请求标志位。

    2. SCON的中断标志

        SCON (Serial Port Control Register) 在[51单片机](https://www.eefocus.com/baike/482800 "51单片机")中代表这是串口控制寄存器，scon控制寄存器，它是一个可位寻址的专用寄存器，用于串行数据的通信控制

        ![](/image/image_rv7TZQp3jJ.png)

        •RI（SCON.0），串行口接收中断标志位。当允许串行口接收数据时，每接收完一个串行帧，由硬件置位RI。CPU响应中断时，不能自动清除RI， RI必须由软件清除。

        •TI（SCON.1），串行口发送中断标志位。当CPU将一个发送数据写入串行口发送缓冲器时，就启动了发送过程。每发送完一个串行帧，由硬件置位TI。同样，TI必须由软件清除。

### 5.1.3  80C51中断的控制

* **中断允许控制**

    CPU对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE控制的。

    ![](/image/image_UjPHChOI6Y.png)

    •EX0(IE.0)，外部中断0允许位；

    •ET0(IE.1)，定时/计数器T0中断允许位；

    •EX1(IE.2)，外部中断1允许位；

    •ET1(IE.3)，定时/计数器T1中断允许位；

    •ES（IE.4)，串行口中断允许位；

    •EA(IE.7)， CPU中断允许（总允许）位。

* **中断优先级控制**

    80C51单片机有两个中断优先级，即可实现二级中断服务嵌套。每个中断源的中断优先级都是由中断优先级寄存器IP中的相应位的状态来规定的 。

    ![](/image/image_jMeHI0Nn4O.png)

    •PX0（IP.0），外部中断0优先级设定位；

    •PT0（IP.1），定时/计数器T0优先级设定位；

    •PX1（IP.2），外部中断0优先级设定位；

    •PT1（IP.3），定时/计数器T1优先级设定位；

    •PS（IP.4），串行口优先级设定位。

&#x20; 同一优先级中的中断申请不止一个时，则有中断优先权排队问题。同一优先级的中断优先权排队，由中断系统硬件确定的自然优先级形成，其排列如所示：

**80C51单片机的中断优先级有三条原则**：

•CPU同时接收到几个中断时，首先响应优先级别最高的中断请求。

![](/image/image_fQLDKScPN7.png)

•正在进行的中断过程不能被新的同级或低优先级的中断请求所中断。

•正在进行的低优先级中断服务，能被高优先级中断请求所中断。

为了实现上述后两条原则，中断系统内部设有两个用户不能寻址的优先级状态触发器。其中一个置1，表示正在响应高优先级的中断，它将阻断后来所有的中断请求；另一个置1，表示正在响应低优先级中断，它将阻断后来所有的低优先级中断请求。

## 5.2 80C51的中断处理过程

### 5.2.1  中断响应条件和时间&#x20;

#### 一、中断响应条件

只有同时满足以下条件,cpu才可能响应

* 中断源有中断请求

* 此中断源的中断请求允许位为1

* CPU开中断(即EA为1)

中断服务的进入：

CPU执行程序过程中，在每个机器周期的S5P2期间，中断系统对各个中断源进行采样。这些采样值在下一个机器周期内按优先级和内部顺序被依次查询

如果某个中断标志在上一个机器周期的S5P2时被置成了1，那么它将于现在的查询周期中及时被发现。接着CPU便执行一条由中断系统提供的硬件LCALL指令，转向被称作中断向量的特定地址单元，进入相应的中断服务程序。&#x20;

#### 二、中断响应时间

某中断的响应时序图：

![](/image/image_Qa4xbwUT3G.png)

* 若M1周期的S5P2前某中断生效，在S5P2期间其中断请求被锁存到相应的标志位中去；M2恰逢指令的最后一个机器周期，且该指令不是RETI或访问IE、IP的指令。于是，M3和M4便可以执行硬件LCALL指令，M5周期将进入了中断服务程序。

* 80C51的中断响应时间（从标志置1到进入相应的中断服务），至少要3个完整的机器周期

### 5.2.2 中断响应过程

•将相应的优先级状态触发器置1（以阻断后来的同级或低级的中断请求）。

•执行一条硬件LCALL指令，即把程序计数器PC的内容压入堆栈保存，再将相应的中断服务程序的入口地址送入PC。

•执行中断服务程序。

中断响应过程的前两步是由中断系统内部自动完成的，而中断服务程序则要由用户编写程序来完成。&#x20;

#### 5.2.3 中断返回

RETI指令的具体功能是：

* 将中断响应是压入堆栈保存的断电地址从栈顶弹出送回PC，CPU从原来中断的地方继续执行程序

* 将相应中断优先级状态触发器清0，通知终端系统，终端服务程序已执行完毕。

注意，不能用RET指令代替RETI指令。在中断服务程序中PUSH指令与POP治理必须成对使用，否则不能正确返回断点。

若外部中断定义为电平触发方式，中断标志位的状态随CPU在每个机器周期采样到的外部中断输入引脚的电平变化而变化，这样能提高CPU对外部中断请求的响应速度。但外部中断源若有请求，必须把有效的低电平保持到请求获得响应时为止，不然就会漏掉；而在中断服务程序结束之前，中断源又必须撤消其有效的低电平，否则中断返回之后将再次产生中断

若外部中断定义为边沿触发方式，在相继连续的两次采样中，一个周期采样到外部中断输入为高电平，下一个周期采样到为低电平，则在IE0或IE1中将锁存一个逻辑1。即便是CPU暂时不能响应，中断申请标志也不会丢失，直到CPU响应此中断时才清零。这样，为保证下降沿能被可靠地采样到，外中断引脚上的高低电平（负脉冲的宽度）均至少要保持一个机器周期（若晶振为12MHz时，为1微秒）。

**例：外部中断控制发光二极管**

```6502&#x20;assembly
ORG  0000H
     AJMP MAIN
     ORG  0003H
     AJMP IN0
     ORG  0030H
MAIN:SETB IT0 ;位设置，把后面的寄存器置1
     SETB EA
     SETB EX0
     AJMP $
IN0: CPL  P1.0
     RETI
     END

```

## 5.3 80C51的定时/计数器

实现定时功能，比较方便的办法是利用单片机内部的定时/计数器。也可以采用下面三种方法：

* 软件定时：软件定时不占用硬件资源，但占用了CPU时间，降低了CPU的利用率

* 采用时基电路定时： 例如采用555电路，外接必要的元器件（电阻和电容），即可构成硬件定时电路。但在硬件连接好以后，定时值与定时范围不能由软件进行控制和修改，即不可编程。

* 采用可编程芯片定时：这种定时芯片的定时值及定时范围很容易用软件来确定和修改，此种芯片定时功能强，使用灵活。在单片机的定时/计数器不够用时，可以考虑进行扩展。

### 5.3.1 定时/计数器的结构和工作原理&#x20;

定时/计数器的实质是加1计数器（16位），由高8位和低8位两个寄存器组成。TMOD是定时/计数器的工作方式寄存器，确定工作方式和功能；TCON是控制寄存器，控制T0、T1的启动和停止及设置溢出标志。&#x20;

![](/image/image_WmhkYxLZi1.png)

加1计数器输入的计数脉冲有两个来源,一个是由系统的时钟振荡器输出脉冲经12分频后送来；一个是T0或T1引脚输入的外部脉冲源。每来一个脉冲计数器加1，当加到计数器为全1时，再输入一个脉冲就使计数器回零，且计数器的溢出使TCON中TF0或TF1置1，向CPU发出中断请求（定时/计数器中断允许时）。如果定时/计数器工作于定时模式，则表示定时时间已到；如果工作于计数模式，则表示计数值已满。

可见，由溢出时计数器的值减去计数初值才是加1计数器的计数值。

### 5.3.2 定时/计数器的控制

80C51单片机定时/计数器的工作由两个特殊功能寄存器控制。TMOD用于设置其工作方式；TCON用于控制其启动和中断申请。

**一、工作方式寄存器TMOD**

工作方式寄存器TMOD用于设置定时/计数器的工作方式，低四位用于T0，高四位用于T1。其格式如下：

![](/image/image_9ZxLTDhZmi.png)

GATE：门控位。GATE＝0时，只要用软件使TCON中的TR0或TR1为1，就可以启动定时/计数器工作；GATE＝1时，要用软件使TR0或TR1为1，同时外部中断引脚也为高电平时，才能启动定时/计数器工作。即此时定时器的启动条件，加上了外部中断引脚为高电平这一条件。

$ C/\overline T
  $:定时/计数模式选择位。 $ C/\overline T
  $＝0为定时模式； $ C/\overline T
  $=1为计数模式。

M1M0：工作方式设置位。定时/计数器有四种工作方式，由M1M0进行设置。

![](/image/image_IeAJayT4cH.png)

**二、控制寄存器TCON**

&#x20;  TCON的低4位用于控制外部中断,已在前面介绍。TCON的高4位用于控制定时/计数器的启动和中断申请。其格式如下：

![](/image/image_uvxmfuuHlO.png)

•TF1（TCON.7）：T1溢出中断请求标志位。T1计数溢出时由硬件自动置TF1为1。CPU响应中断后TF1由硬件自动清0。T1工作时，CPU可随时查询TF1的状态。所以，TF1可用作查询测试的标志。TF1也可以用软件置1或清0，同硬件置1或清0的效果一样。

•TR1（TCON.6）：T1运行控制位。TR1置1时，T1开始工作；TR1置0时，T1停止工作。TR1由软件置1或清0。所以，用软件可控制定时/计数器的启动与停止。

•TF0（TCON.5）：T0溢出中断请求标志位，其功能与TF1类同。

•TR0（TCON.4）：T0运行控制位，其功能与TR1类同。

### 5.3.3  定时/计数器的工作方式        &#xD;

**一、方式0**

方式0为13位计数，由TL0的低5位（高3位未用）和TH0的8位组成。TL0的低5位溢出时向TH0进位，TH0溢出时，置位TCON中的TF0标志，向CPU发出中断请求

![](/image/image_Z9UDS9BhEN.png)

定时器模式时有:N＝t/ Tcy

计数初值计算的公式为：$ X=2^{13}-N
  $

定时器的初值还可以采用计数个数直接取补法获得。

计数模式时，计数脉冲是T0引脚上的外部脉冲。

门控位GATE具有特殊的作用。当GATE=0时，经反相后使或门输出为1，此时仅由TR0控制与门的开启，与门输出1时，控制开关接通，计数开始；当GATE=1时，由外中断引脚信号控制或门的输出，此时控制与门的开启由外中断引脚信号和TR0共同控制。当TR0=1时，外中断引脚信号引脚的高电平启动计数，外中断引脚信号引脚的低电平停止计数。这种方式常用来测量外中断引脚上正脉冲的宽度。

**二、方式1**

方式1的计数位数是16位，由TL0作为低8位、TH0作为高8位，组成了16位加1计数器。

![](/image/image_5gnZOOU9fD.png)

计数个数与计数初值的关系为： $ X=2^{16}-N(定时时间，单位:\mu s)
  $

**三、方式2**

方式2为自动重装初值的8位计数方式。

计数个数与计数初值的关系为： $ X=2^8-N
  $

![](/image/image_Lgj2_QiVTC.png)

工作方式2特别适合于用作较精确的脉冲信号发生器。 &#x20;

**四、方式3**

方式3只适用于定时/计数器T0，定时器T1处于方式3时相当于TR1=0，停止计数。

![](/image/image_TsTH0g9cE4.png)

工作方式3将T0分成为两个独立的8位计数器TL0和TH0&#x20;

### 5.3.4 定时/计数器用于外部中断扩展 &#x20;

扩展方法是，将定时/计数器设置为计数器方式，计数初值设定为满程，将待扩展的外部中断源接到定时/计数器的外部计数引脚。从该引脚输入一个下降沿信号，计数器加1后便产生定时/计数器溢出中断。

例如，利用T0扩展一个外部中断源。将T0设置为计数器方式，按方式2工作，TH0、TL0的初值均为0FFH，T0允许中断，CPU开放中断。

```6502&#x20;assembly
MOV  TMOD，#06H       ;置T0为计数器方式2
MOV  TL0，#0FFH       ;置计数初值
MOV  TH0，#0FFH
SETB TR0              ;启动T0工作
SETB EA               ;CPU开中断
SETB ET0              ;允许T0中断             

```

例  利用定时/计数器T0的方式1，产生10ms的定时，并使P1.0引脚上输出周期为20ms的方波，采用中断方式，设系统时钟频率为12 MHz。

```makefile
        ORG   0000H
        LJMP  MAIN                ;跳转到主程序
        ORG   000BH               ;T0的中断入口地址
        LJMP  DVT0                ;转向中断服务程序
        ORG   0100H
  MAIN：MOV   TMOD，#01H ；置T0工作于方式1
        MOV   TH0，#0D8H         ;装入计数初值
        MOV   TL0，#0F0H          
        SETB  ET0                ;T0开中断
        SETB  EA                 ;CPU开中断
        SETB  TR0                ;启动T0
        SJMP $                   ;等待中断
  DVT0：CPL  P1.0                ;P1.0取反输出
        MOV  TH0，#0D8H          ；重新装入计数值
        MOV  TL0，#0F0H           
        RETI                     ;中断返回
        END

```

# 6. 串行通信

## 6.1 计算机串行通信基础

•随着多微机系统的广泛应用和计算机网络技术的普及，计算机的通信功能愈来愈显得重要。计算机通信是指计算机与外部设备或计算机与计算机之间的信息交换。

•通信有并行通信和串行通信两种方式。在多微机系统以及现代测控系统中信息的交换多采用串行通信方式。

* 并行通信通常是将数据字节的各位用多条数据线同时进行传送。

    并行通信控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难

    ![](/image/image_aGKf6Mshih.png)

* 串行通信是将数据字节分成一位一位的形式在一条传输线上逐个地传送。

    串行通信的特点：传输线少，长距离传送时成本低，且可以利用电话网等现成的设备，但数据的传送控制比并行通信复杂。 &#x20;

    ![](/image/image_SlxngCQqIp.png)

### 6.1.1串行通信的基本概念

**一、异步通信与同步通信**

1. 异步通信

    异步通信是指通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程。为使双方的收发协调，要求发送和接收设备的时钟尽可能一致。

    ![](/image/image_qMFnQIrX8N.png)

    异步通信是以字符（构成的帧）为单位进行传输，字符与字符之间的间隙（时间间隔）是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间是异步的（字符之间不一定有“位间隔”的整数倍的关系），但同一字符内的各位是同步的（各位之间的距离均为“位间隔”的整数倍）。

    **异步通信的数据格式 ：**

    ![](/image/image_Z4OMF3yZWE.png)

    异步通信的特点：不要求收发双方时钟的严格一致，实现容易，设备开销较小，但每个字符要附加2～3位用于起止位，各帧之间还有间隔，因此传输效率不高。

2. 同步通信

    同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步可以通过两种方法实现。 &#x20;

    ![](/image/image_ohVdvf3p3q.png)

    1. **面向字符的同步格式：**

        ![](/image/image_3N6QmoQIxR.png)

        此时，传送的数据和控制信息都必须由规定的字符集（如ASCII码）中的字符所组成。图中

        帧头为1个或2个同步字符SYN（ASCII码为16H）。

        SOH为序始字符（ASCII码为01H，表示标题的开始）

        标题中包含源地址、目标地址和路由指示等信息。

        STX为文始字符（ASCII码为02H），表示传送的数据块开始。

        数据块是传送的正文内容，由多个字符组成。

        数据块后面是组终字符ETB（ASCII码为17H）或文终字符ETX（ASCII码为03H）。

        典型的面向字符的同步规程如IBM的二进制同步规程BSC。&#x20;

    2. **面向位的同步格式：**

        ![](/image/image_UHUxOBxBwY.png)

        此时，将数据块看作数据流，并用序列01111110作为开始和结束标志。为了避免在数据流中出现序列01111110时引起的混乱，发送方总是在其发送的数据流中每出现5个连续的1就插入一个附加的0；接收方则每检测到5个连续的1并且其后有一个0时，就删除该0。

## 6.2 80C51的串行口

## 6.3 单片机 串行口应用举例
